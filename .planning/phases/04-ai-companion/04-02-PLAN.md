---
phase: 04-ai-companion
plan: "02"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/chatStore.ts
  - src/components/chat/GlobalChatbar.tsx
  - src/components/article/SendToChatButton.tsx
autonomous: true
requirements:
  - CHAT-01
  - CHAT-02
  - CHAT-06

must_haves:
  truths:
    - "The Global Chatbar is always visible at the bottom of the screen in a minimal pill state"
    - "Clicking or focusing the chatbar expands it into a drawer input state"
    - "The chatbar placeholder text is context-aware (shows article title if on article page)"
    - "'Send to Chat' button on the article wires the article title into the chat store so the chat knows what article is being discussed"
    - "Chat store tracks: messages, chatMode (minimal/drawer/sidebar/fullscreen), articleContext"
  artifacts:
    - path: "src/lib/chatStore.ts"
      provides: "Shared Zustand-free chat state via React context + localStorage persistence"
      exports: ["ChatStore", "useChatStore", "ChatProvider", "ChatMessage", "ChatMode"]
    - path: "src/components/chat/GlobalChatbar.tsx"
      provides: "Upgraded chatbar with minimal pill + drawer states, reads from chatStore"
      min_lines: 80
    - path: "src/components/article/SendToChatButton.tsx"
      provides: "Wires article title into chatStore articleContext on click"
      min_lines: 25
  key_links:
    - from: "src/components/article/SendToChatButton.tsx"
      to: "src/lib/chatStore.ts"
      via: "useChatStore().setArticleContext(articleTitle)"
      pattern: "setArticleContext|articleContext"
    - from: "src/components/chat/GlobalChatbar.tsx"
      to: "src/lib/chatStore.ts"
      via: "useChatStore() reads chatMode, messages, articleContext"
      pattern: "useChatStore"
---

<objective>
Establish the shared chat state store and upgrade GlobalChatbar to multi-state behavior, and wire SendToChatButton to pass article context.

Purpose: All chat surfaces (chatbar, sidebar, fullscreen) share the same conversation and context state. This plan creates the foundation that plans 04-03 and 04-04 build on. Without the store, sidebar and fullscreen cannot be coherent.
Output: chatStore (shared state), upgraded GlobalChatbar (minimal + drawer), wired SendToChatButton.
</objective>

<execution_context>
@/Users/jccruzb-local/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jccruzb-local/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/constants.ts
@src/lib/types.ts
@src/components/chat/GlobalChatbar.tsx
@src/components/article/SendToChatButton.tsx
@src/app/(app)/layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create chatStore — shared chat state with localStorage persistence</name>
  <files>src/lib/chatStore.ts</files>
  <action>
    Create `src/lib/chatStore.ts` — a React Context-based store (no Zustand, no Redux — keep to project "no heavy libraries" rule).

    Export the following types and functions:

    ```ts
    export type ChatMode = "minimal" | "drawer" | "sidebar" | "fullscreen";

    export interface ChatMessage {
      id: string;
      role: "user" | "assistant";
      content: string;
      timestamp: number;
    }

    export interface ChatStore {
      messages: ChatMessage[];
      chatMode: ChatMode;
      articleContext: string | null; // article title currently being discussed
      addMessage: (msg: Omit<ChatMessage, "id" | "timestamp">) => void;
      setChatMode: (mode: ChatMode) => void;
      setArticleContext: (title: string | null) => void;
      clearMessages: () => void;
    }
    ```

    Implementation:
    - Create a React Context (`ChatContext`) with the `ChatStore` interface
    - Create `ChatProvider` component that:
      - Uses `useState` for `messages`, `chatMode` (default `"minimal"`), `articleContext` (default `null`)
      - On mount (useEffect): loads persisted messages from `localStorage.getItem("cultx:chat")` — parse JSON array, set if valid
      - On messages change (useEffect): saves to `localStorage.setItem("cultx:chat", JSON.stringify(messages))`
      - `addMessage`: appends new message with `id: crypto.randomUUID()`, `timestamp: Date.now()`
      - `setChatMode`: updates chatMode state
      - `setArticleContext`: updates articleContext state
      - `clearMessages`: resets messages to `[]`, also clears localStorage key `"cultx:chat"`
    - Create `useChatStore` hook: `() => useContext(ChatContext)` — throws if used outside provider
    - Add SSR guard: all localStorage access behind `typeof window !== "undefined"` check

    Wire `ChatProvider` into `src/app/(app)/layout.tsx` — wrap the layout children with `<ChatProvider>`. Since layout.tsx is a server component, create `src/components/chat/ChatProvider.tsx` as a `"use client"` re-export of the provider, then import that into layout.tsx.

    Actually: Keep all chat store logic in `src/lib/chatStore.ts` and mark it with `"use client"` at the top. The layout.tsx must import the provider from this file.

    IMPORTANT: `src/app/(app)/layout.tsx` is currently a server component. Create `src/components/chat/ChatProvider.tsx` as a thin `"use client"` wrapper that re-exports the context and provider — this avoids making layout.tsx a client component. Pattern:

    ```tsx
    // src/components/chat/ChatProvider.tsx
    "use client";
    export { ChatProvider, useChatStore } from "@/lib/chatStore";
    ```

    Then in `src/app/(app)/layout.tsx`:
    ```tsx
    import { ChatProvider } from "@/components/chat/ChatProvider";
    // wrap children: <ChatProvider>{children}</ChatProvider>
    // GlobalChatbar goes inside ChatProvider too
    ```
  </action>
  <verify>
    Run `npx tsc --noEmit` — zero TypeScript errors.
    Check `src/lib/chatStore.ts` exports `ChatProvider`, `useChatStore`, `ChatMessage`, `ChatMode`, `ChatStore`.
    Check `src/components/chat/ChatProvider.tsx` exists and re-exports correctly.
    Check `src/app/(app)/layout.tsx` wraps children with `ChatProvider`.
  </verify>
  <done>
    ChatProvider wraps the app layout. useChatStore hook available in any client component under (app) route group. Messages persist to localStorage key "cultx:chat". chatMode defaults to "minimal".
  </done>
</task>

<task type="auto">
  <name>Task 2: Upgrade GlobalChatbar and wire SendToChatButton</name>
  <files>
    src/components/chat/GlobalChatbar.tsx
    src/components/article/SendToChatButton.tsx
  </files>
  <action>
    ## GlobalChatbar.tsx — upgrade to use chatStore

    Replace the current local-state-only implementation with one that reads from `useChatStore()`:

    ```tsx
    "use client";
    import { useChatStore } from "@/components/chat/ChatProvider";
    ```

    Three rendered states based on `chatMode` from store:

    **State 1 — "minimal"** (chatMode === "minimal" or "sidebar" or "fullscreen"):
    When mode is sidebar or fullscreen, render nothing (the sidebar/fullscreen component handles its own UI). When mode is "minimal":
    - Same pill button as before but with richer placeholder text
    - Placeholder: if `articleContext` is set, show `"Pregunta sobre «${articleContext}»…"` else `"Pregunta sobre cultura mexicana…"`
    - On click: call `setChatMode("drawer")`
    - Keep Phosphor `ChatTeardrop` icon, weight="thin", accent color

    **State 2 — "drawer"** (chatMode === "drawer"):
    - Expanded bottom bar (existing expanded layout is fine as base)
    - Textarea placeholder same context-aware text as pill
    - If `articleContext` is set: show a small context badge above the textarea: `"Contexto: ${articleContext}"` with X button that calls `setArticleContext(null)`
    - Two action buttons on the right column (stacked):
      1. `X` icon — calls `setChatMode("minimal")`, aria-label="Cerrar chat"
      2. `ArrowsOut` icon (Phosphor, weight="thin") — calls `setChatMode("sidebar")`, aria-label="Abrir como panel lateral"
      3. `ArrowUp` icon — send button (disabled when textarea empty). On click: calls `addMessage({ role: "user", content: inputValue })`, clears textarea. AI response logic comes in plan 04-04 — for now just add the user message.
    - Keep all existing token-based styling patterns

    **State "sidebar" / "fullscreen"**: GlobalChatbar renders null (sidebar and fullscreen components handle rendering).

    ## SendToChatButton.tsx — wire to chatStore

    Replace the mock notice logic with actual chatStore wiring:
    ```tsx
    "use client";
    import { useChatStore } from "@/components/chat/ChatProvider";
    ```

    On button click:
    1. Call `setArticleContext(articleTitle)` — pass the article title as context (rename prop from `_articleTitle` to `articleTitle`)
    2. Call `setChatMode("drawer")` — open the chatbar drawer so user sees the context was applied
    3. Show a small inline confirmation for 2s: `"Artículo enviado al chat"` (replaces old "Fase 4" stub notice)

    Update the prop name in `SendToChatButton` from `_articleTitle` to `articleTitle`. Update `src/app/(app)/article/[id]/page.tsx` (or `ArticlePageClient.tsx` created in plan 04-01) to pass `articleTitle={article.title}` instead of `_articleTitle`.

    Keep the button's visual design identical (pill, ChatTeardrop icon, same hover/focus styles).
  </action>
  <verify>
    Run `npm run build` — zero errors.
    Navigate to article page. Click "Enviar al chat" — chatbar expands into drawer with context badge showing article title. Close drawer — returns to pill. Reopen pill — shows article title in placeholder. Click ArrowsOut icon — sets chatMode to "sidebar" (GlobalChatbar disappears; plan 04-03 will render the sidebar instead).
  </verify>
  <done>
    GlobalChatbar reads chatMode and articleContext from the shared store.
    Pill placeholder is context-aware when an article has been sent to chat.
    Drawer shows article context badge with option to clear it.
    Drawer has ArrowsOut button to transition to sidebar mode.
    SendToChatButton writes articleContext and opens drawer — no more stub notice.
    All state persists across components via ChatProvider context.
  </done>
</task>

</tasks>

<verification>
Run `npm run build` — zero errors, zero TypeScript errors.
Full flow: visit article page → click "Enviar al chat" → chatbar expands as drawer with article title as context badge → close → pill shows article title placeholder → expand again → ArrowsOut icon click changes chatMode to "sidebar".
localStorage key "cultx:chat" stores messages as JSON array.
</verification>

<success_criteria>
CHAT-01 satisfied: Global Chatbar visible in minimal pill state with context-aware placeholder.
CHAT-02 satisfied: Chatbar expands into drawer on click/focus.
CHAT-06 satisfied: "Send to Chat" sets articleContext in chatStore, chatbar reflects the article title.
Shared chatStore foundation ready for 04-03 (sidebar/fullscreen) and 04-04 (AI responses).
</success_criteria>

<output>
After completion, create `.planning/phases/04-ai-companion/04-02-SUMMARY.md` with what was built, key decisions, and file list.
</output>
